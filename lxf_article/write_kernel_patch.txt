
First up, some basics about the source code control tool that the Linux
kernel uses, git.  Git can be found in any Linux distro these days, and
there are numerous good tutorials on how to use it and set it up
availble on the web.  One good one is comes within git itself, and can
be read by running:
	$ man gittutorial
after you have installed git on your machine.

So run off and install git on your Linux system using the package
manager you are comfortable with (personally, I use openSUSE, and a
simple 'zypper install git' does everything that is needed.)

Then start by cloning the main Linux kernel repository:

	$ mkdir ~/linux
	$ cd ~/linux
	$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git

This will create the directory 'linux-2.6' within the linux/ directory.
Everything we do from here out will be within that directory, so go into
it to start with:
	$ cd ~/linux/linux-2.6

Now that you have the raw source code, how do you build it and install
it on your system?  That is a much larger task, one that is beyond this
article.  Luckily a whole book has been written on this topic, "Linux
Kernel in a Nutshell", and can be found free online at:
	http://www.kroah.com/lkn/
if you don't want to purchase it.

So go and get your kernel configured and building, and then come back
here to figure out what to do next.


-- Git tips

Here are a few tips to use with git when working with the kernel source
tree.  First off, never do your work on the same branch that Linus
pushes to, called "master".  Create your own branch, and use that
instead.  This ensures that any changes that are committed to Linus's
branch upstream, will be able to be updated by you without any problems.

To create a new branch called 'tutorial' and check it out, do the
following:
	$ git branch tutorial
	$ git checkout tutorial
That's it.  You are now in the 'tutorial' branch of your kernel
repository, as can be seen by the following command:
	$ git branch
	   master
	 * tutorial
The '*' in front of the 'tutorial' name shows that you are on the
correct branch.

Now, let's go and make some changes to the kernel code.

-- What to change

Wait, you don't know what change you want to make to the Linux kernel
source tree?  Everything is working just fine for you?  Well, don't
dispair, the Linux kernel developers need all the help they can get, and
have plenty of code in the tree that is just waiting to get cleaned up.

The code in the drivers/staging/ tree consists of a lot of drivers that
do not meet the normal Linux kernel coding guidelines.  The code is in
that location so that other developers can help on cleaning it up, and
getting it merged into the main portion of the Linux kernel tree.

Every driver in the drivers/staging directory contains a TODO file that
lists the things that need to be done on it in order for the code to be
moved to the proper location in the kernel tree.  The majority of the
drivers all contain the following line in their TODO file:
	- fix checkpatch.pl issues

Let's look into what this means and how you can help out with this task.

-- Coding Style

Every large body of code needs to have a set of coding style rules in
order for it to be a viable project that a large number of developers
can work on.  Numerous research studies have been made on this topic,
and they all conclude that having a common guideline makes a very large
difference.

	It is not merely a matter of aesthetics that programs
	should be written in a particular style.  Rather there
	is a psychological basis for writing programs in a
	conventional manner: programmers have strong expectations
	that other programmers will follow these discourse rules.
	If the rules are violated, then the utility afforded by
	the expectations that programmers have built up over time
	is effectively nullified.”
                              – Soloway & Ehrlich

What this means is that once programmers get used to a common style, the
patterns of the code go away when it is looked at, and the meaning shows
through very easily.

The goal of any Linux kernel developer is to have other developers help
find problems in their code, and by keeping all of the code in the same
format, it makes it much easier for anyone else to pick it up, modify
it, or notice bugs in it.  As every line of kernel code is reviewed by
at least 2 developers before it is accepted, having a common style
guideline is a very important thing.

The Linux kernel coding style can be found in the file
Documentation/CodingStyle in the kernel source tree.  The important
thing to remember when reading it, is not that this style is somehow
better than any other style, just that it is consistent.

In order to help developers easily find coding style issues, the script
scripts/checkpatch.pl in the kernel source tree has been developed.
This script can point out problems very easily, and should always be run
by a developer on their changes, instead of having a reviewer waste
their time by pointing out problems later on.

The drivers in the drivers/staging/ directory all usually have coding
style issues as they were developed by people not familiar with the
Linux kernel guidelines.  One of the first thing that needs to be done
to the code, is to fix it up to follow the correct rules.

And this is where you come in, by running the checkpatch.pl tool, you
can find a large number of problems that need to be fixed.

-- Specific rules

Let us look at some of the common rules that are part of the kernel
guidelines.

--- Whitespace

The first rule that everyone needs to follow is to use the 'tab'
character, and not use spaces, to indent code.  Also, the 'tab'
character should represent 8 spaces.  Following along with the 8
character tab indentation, the code should not flow past the 80
character line limit on the right side of the screen.

Note, numerous developers have complained about the 80 character limit
recently, and there are some places where it is acceptable to go beyond
that limit.  If you find that you are being forced to do strange
line-wrapping formatting just to fit into the 80 character limit, with
all of your code on the right hand side of the screen, it is better to
refactor the logic to prevent this from happening in the first place.
Forcing an 80 character limit, also forces developers to break their
logic up into tinyer, easier to understand chunks, which makes it easier
to review and follow as well.

So yes, there is a method to the madness of the 80 character limit.

--- Braces

Opening braces should be placed on the same line of the statement they
are being used for, with one exception as show below.  Closing braces
should be placed back at the original indentation.  This can be shown
with the following example:

	if (error != -ENODEV) {
	        foo();
	        bar();
	}

If you need to add an else statement to an if statement, put it on the
same line as the closing brace, as shown here:

	if (error != -ENODEV) {
	        foo();
	        bar();
	} else {
		report_error();
		goto exit;
	}

If braces are not needed for a statement, do not put them in, as they
are unnecessary:

	if (error != -ENODEV)
	        foo();
	else
		goto exit;

The one exception for opening braces, is for function declarations,
those go on a new line as shown here:

	int function(int *baz)
	{
	        do_something(baz);
	        return 0;
	}

-- checkpatch.pl

With these simple whitespace and brace rules now understood, let us run
the checkpatch.pl script on some code and see what it tells us:

	$ ./scripts/checkpatch.pl --help
	Usage: checkpatch.pl [OPTION]... [FILE]...
	Version: 0.30

	Options:
	  -q, --quiet                quiet
	  --no-tree                  run without a kernel tree
	  --no-signoff               do not check for 'Signed-off-by' line
	  --patch                    treat FILE as patchfile (default)
	  --emacs                    emacs compile window format
	  --terse                    one line per report
	  -f, --file                 treat FILE as regular source file
	  --subjective, --strict     enable more subjective tests
	  --root=PATH                PATH to the kernel tree root
	  --no-summary               suppress the per-file summary
	  --mailback                 only produce a report in case of warnings/errors
	  --summary-file             include the filename in summary
	  --debug KEY=[0|1]          turn on/off debugging of KEY, where KEY is one of
				     'values', 'possible', 'type', and 'attr' (default
				     is all off)
	  --test-only=WORD           report only warnings/errors containing WORD
				     literally
	  -h, --help, --version      display this help and exit

	When FILE is - read standard input.

Some common options that we will be using is the --terse and --file
options, as those allow us to see the problems in a much simpler report,
and they work on an entire file, not just a single patch.

So, let's pick a file in the kernel and see what checkpatch.pl tells us
about it:

	$ ./scripts/checkpatch.pl --file --terse drivers/staging/

This is because of one thing that all developers have in
common, they have a brain.


The Linux kernel is no exception and describes al








git stuff

	git branch tutorial
	git checkout tutorial
	git status

checkpatch stuff

	./scripts/checkpatch.pl  (empty for help)
	--terse
	--file

pick a file

	checkpatch comedi file

show errors vs warnings

coding style
	why?
	what is it?
	80 columns
	tabs
	brace placement
	* placement
	Documentation/CodingStyle


edit the file

change the line, run checkpatch.

git diff

git commit

Good changelog comment

signed-off-by:
	what it is

git show
	--pretty=email

git format-patch

git send-email
	 --smtp-server /usr/bin/msmtp

	 git config --global sendemail.smtpserver /usr/bin/msmtp




